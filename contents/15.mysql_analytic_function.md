# 분석 함수

SQL에는 분석 처리에 유용한 함수 집합이 포함되어있음. 고객을 위한 재무 보고서를 생성하고, 3개월 연속 평균을 계산해야 할 경우, SQL이 기본 제공하는 내장 분석함수로 이러한 유형의 작업을 수행할 수 있음

## 분석 함수의 개념

데이터베이스 서버가 조인, 필터링, 그룹화 및 정렬을 포함하여 쿼리를 검증하는데 필요한 모든 단계를 끝내면 결과셋이 완성되어 호출자에게 반환될 준비가 됨. 이 시점에서 쿼리 실행을 일시 중지하고 메모리에 저장된
결과를 살펴볼 수 있다면. 결과셋에 판매 데이터가 포함되어 있다면 영업 사원 실적 순위 또는 지역에 대한 순위를 생성하거나, 특정 기간과 다른 기간 간의 백분율 차이를 계산할 수 있음. 분석함수를 사용하면 이러한
모든 작업을 수행할 수 있음.

### 데이터 윈도우

```sql
SELECT QUARTER(payment_date) quarter, MONTHNAME(payment_date) month_nm, SUM(amount) monthly_sales
FROM payment
WHERE YEAR (payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date);

+---------+----------+---------------+
| quarter | month_nm | monthly_sales |
+---------+----------+---------------+
|       2 | June     |       9631.88 |
|       2 | May      |       4824.43 |
|       3 | August   |      24072.13 |
|       3 | July     |      28373.89 |
+---------+----------+---------------+
4 rows in set (0.016 sec)
```

4개월 동안 7월간의 월간합계가 가장 높았고, 2분기에는 6월이 가장 높은 월간 합계를 보임. 프로그래밍 방식으로 가장 높은 값을 결정하려면 분기당 최대값 및 전체 기간에 대한 최댓값을 표시하는 열을 각 행에 추가해야함.
```sql
SELECT QUARTER(payment_date)                                      quarter,
	   MONTHNAME(payment_date)                                    month_nm,
	   SUM(amount)                                                monthly_sales,
	   MAX(SUM(amount)) OVER ()                                   max_overall_sales,
		MAX(SUM(amount)) OVER (PARTITION BY QUARTER(payment_date)) max_qrtr_sales

FROM payment
WHERE YEAR(payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date);

+---------+----------+---------------+-------------------+----------------+
| quarter | month_nm | monthly_sales | max_overall_sales | max_qrtr_sales |
+---------+----------+---------------+-------------------+----------------+
|       2 | June     |       9631.88 |          28373.89 |        9631.88 |
|       2 | May      |       4824.43 |          28373.89 |        9631.88 |
|       3 | August   |      24072.13 |          28373.89 |       28373.89 |
|       3 | July     |      28373.89 |          28373.89 |       28373.89 |
+---------+----------+---------------+-------------------+----------------+
4 rows in set (0.023 sec)
```

추가 열을 생성하는데 사용되는 분석 함수는 행을 두 개의 집합으로 그룹화 함. 하나는 모든 행을 포함, 다음하나는 모든 행을 포함함. 이러한 유형의 분석을 수용하기 위해 분석 함수에는 행을 윈도우로 그룹화하는 기능이
포함되어 있음. 이 기능은 전체 전체 결과셋을 변경하지 않으면서 분석 함수에서 사용할 데이터를 효과적으로 분할함.

윈도우는 선택적인 PARTITION BY 하위절과 결합된 OVER절을 사용하여 정의됨. 첫 번째 함수의 OVER절은 비어있으므로 윈도우 전체 결과셋에 포함되며, 두 번째 부석함수에는 같은 분기 내의 행에만 포함됨.
데이터 윈도우는 단일 행부터 결과셋에 전체 행에 이르는 모든 행을 포함할 수 있으며, 다양한 분석 함수로 각기 다른 데이터 윈도우를 정의할 수 있음.


## 로컬 정렬

분석 기능을 위해 결과셋을 데이터 윈도우로 분할하는 것과 함께 정렬 순서를 지정할 수도 있음.
```sql
# 판매량이 가장 높은 달에 값 1이 주어지는 각 월의 순위 번호를 정의하는 쿼리
SELECT QUARTER(payment_date)                   quarter,
	   MONTHNAME(payment_date)                 month_nm,
	   SUM(amount)                             monthly_sales,
	   RANK() OVER (ORDER BY SUM(amount) DESC) sales_rank

FROM payment

WHERE YEAR(payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date)
ORDER BY 1, MONTH(payment_date);

+---------+----------+---------------+------------+
| quarter | month_nm | monthly_sales | sales_rank |
+---------+----------+---------------+------------+
|       2 | May      |       4824.43 |          4 |
|       2 | June     |       9631.88 |          3 |
|       3 | July     |      28373.89 |          1 |
|       3 | August   |      24072.13 |          2 |
+---------+----------+---------------+------------+
4 rows in set (0.019 sec)
```

경우에 따라 동일한 분석 함수 호출에서 PARTITION BY 및 ORDER BY 하위절을 모두 사용하려 할 수 있음. 전체 결과셋에서 단일 순위 대신 분기별 순위를 제공하도록 이전 예제를 다음과 같이 수정할 수
있음.

```sql
SELECT QUARTER(payment_date)                                                      quarter,
       MONTHNAME(payment_date)                                                    month_nm,
       SUM(amount)                                                                montly_sales,
       RANK() OVER (PARTITION BY QUARTER(payment_date) ORDER BY SUM(amount) desc) qtr_sales_rank

FROM payment
WHERE YEAR(payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date), QUARTER(payment_date)
ORDER BY 1, MONTH(payment_date);

+---------+----------+--------------+----------------+
| quarter | month_nm | montly_sales | qtr_sales_rank |
+---------+----------+--------------+----------------+
|       2 | May      |      4824.43 |              2 |
|       2 | June     |      9631.88 |              1 |
|       3 | July     |     28373.89 |              1 |
|       3 | August   |     24072.13 |              2 |
+---------+----------+--------------+----------------+
4 rows in set (0.04 sec)
```

## 순위

### 순위 함수

SQL 표준에는 여러 순위 기능을 사용할 수 있으며, 각 순위 기능은 동점 처리 방식에 대해 서로 다른 접근 방식을 취함.
* row_number: 동점일 경우 순위가 임의로 지정된 각 행의 고유 번호를 반환함
* RANK: 동점일 경우 순위에 차이가 있는 동일한 순위를 반환함
* dense_rankL 동점일 경우 순위에 차이가 없는 동일한 순위를 반환함

상위 10명의 고객을 파악하여 무료 영화 대여 서비스를 제공하는 쿼리
```sql
# 각 고객의 영화 대여 수를 결정하고 결과를 내림차순으로 정렬
SELECT customer_id, COUNT(*) num_rentals
FROM rental
GROUP BY customer_id
ORDER BY 2 DESC;

+-------------+-------------+
| customer_id | num_rentals |
+-------------+-------------+
|         148 |          46 |
|         526 |          45 |
|         144 |          42 |
|         236 |          42 |
|          75 |          41 |
|         197 |          40 |
...
|         110 |          14 |
|         281 |          14 |
|         318 |          12 |
+-------------+-------------+
599 rows in set (0.01 sec)
```

세 번째와 네 번째 고객은 어떤 순서를 우선으로 잡아야할지 모름 동점을 처리하는 방식은 다음과 같음
```sql
SELECT customer_id,
       COUNT(*)                                   num_rentals,
       ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) row_number_rnk,
       RANK() OVER (ORDER BY COUNT(*) DESC)       rank_rnk,
       DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) dense_rank_rnk
FROM rental
GROUP BY customer_id
ORDER BY 2 DESC;


+-------------+-------------+----------------+----------+----------------+
| customer_id | num_rentals | row_number_rnk | rank_rnk | dense_rank_rnk |
+-------------+-------------+----------------+----------+----------------+
|         148 |          46 |              1 |        1 |              1 |
|         526 |          45 |              2 |        2 |              2 |
|         144 |          42 |              3 |        3 |              3 |
|         236 |          42 |              4 |        3 |              3 |
|          75 |          41 |              5 |        5 |              4 |
|         197 |          40 |              6 |        6 |              5 |
|         469 |          40 |              7 |        6 |              5 |
|         137 |          39 |              8 |        8 |              6 |
|         178 |          39 |              9 |        8 |              6 |
|         468 |          39 |             10 |        8 |              6 |
|           5 |          38 |             11 |       11 |              7 |
|         295 |          38 |             12 |       11 |              7 |
|         410 |          38 |             13 |       11 |              7 |
|         459 |          38 |             14 |       11 |              7 |
|         176 |          37 |             15 |       15 |              8 |
|         198 |          37 |             16 |       15 |              8 |
|         257 |          37 |             17 |       15 |              8 |
|         366 |          37 |             18 |       15 |              8 |
|          29 |          36 |             19 |       19 |              9 |
|         267 |          36 |             20 |       19 |              9 |
|         348 |          36 |             21 |       19 |              9 |
|         354 |          36 |             22 |       19 |              9 |
|         380 |          36 |             23 |       19 |              9 |
|         439 |          36 |             24 |       19 |              9 |
|          21 |          35 |             25 |       25 |             10 |
|          50 |          35 |             26 |       25 |             10 |
|          91 |          35 |             27 |       25 |             10 |
|         196 |          35 |             28 |       25 |             10 |
|         204 |          35 |             29 |       25 |             10 |
|         273 |          35 |             30 |       25 |             10 |
|         274 |          35 |             31 |       25 |             10 |
|         368 |          35 |             32 |       25 |             10 |
|         371 |          35 |             33 |       25 |             10 |
|         373 |          35 |             34 |       25 |             10 |
|         381 |          35 |             35 |       25 |             10 |
|         403 |          35 |             36 |       25 |             10 |
|         506 |          35 |             37 |       25 |             10 |
|          26 |          34 |             38 |       38 |             11 |
|          30 |          34 |             39 |       38 |             11 |
|          38 |          34 |             40 |       38 |             11 |
|          46 |          34 |             41 |       38 |             11 |
|          66 |          34 |             42 |       38 |             11 |
...
|         110 |          14 |            597 |      596 |             31 |
|         281 |          14 |            598 |      596 |             31 |
|         318 |          12 |            599 |      599 |             32 |
+-------------+-------------+----------------+----------+----------------+
599 rows in set (0.01 sec)
```

세 번째 열은 row_number() 함수를 사용하여 동점에 관계없이 각 행에 고유한 순위를 지정함.

네 번째, 다섯 번째 열은 동점일 경우 동일한 순위를 지정한다는 점에서는 같지만, 동점 이후의 순윗값을 열에 매기는지 여부에 차이가 있음.


* 상위 10명의 고객을 식별하는 방법은 다음과 같음
  * row_number() 함수로 1에서 10위 까지의 순위를 매긴 고객을 식별함, 10위의 고객과 동일한 대여 횟수가 있는 고객을 제외할 수 있음.
  * rank() 함수로 10위까지의 고객을 식별하여 정확히 10명의 고객을 추릴 수 있음.
  * dense_rank() 함수로 10위 내의 고객을 식별하면 37명의 고객을 추릴 수 있음.

동일한 순위가 없으면 이중 어떤 함수를 사용해도 무방하나, 대부분의 경우 rank()가 최선의 선택.

### 다양한 순위 생성
전의 쿼리는 전체 고객 집합에서 단일 순위를 생성하지만, 동일한 결과셋에서 여러 순위의 집합을 생성하려면?
```sql
# 매월 상위 5명의 고객에게 무료 영화 대여 서비스를 제공하는 쿼리
SELECT customer_id, MONTHNAME(rental_date) rental_month, COUNT(*) num_rentals
FROM rental
GROUP BY customer_id, MONTHNAME(rental_date)
ORDER BY 2, 3 DESC;

+-------------+--------------+-------------+
| customer_id | rental_month | num_rentals |
+-------------+--------------+-------------+
|         569 | August       |          18 |
|         119 | August       |          18 |
|         148 | August       |          18 |
|          15 | August       |          18 |
|         342 | August       |          17 |
|         141 | August       |          17 |
...
|         431 | May          |           1 |
|         351 | May          |           1 |
|          10 | May          |           1 |
|         136 | May          |           1 |
|          61 | May          |           1 |
+-------------+--------------+-------------+
2466 rows in set (0.02 sec)
```
매달 새로운 순위 집합을 만드려면, 결과셋을 서로 다른 데이터 윈도우(월 기준)로 나누는 방법을 설명하는 RANK()함수에 추가해야함
```sql
SELECT customer_id,
       MONTHNAME(rental_date)                                                   rental_month,
       COUNT(*)                                                                 num_rentals,
       RANK() OVER (PARTITION BY MONTHNAME(rental_date) ORDER BY COUNT(*) DESC) rank_rnk
FROM rental
GROUP BY customer_id, MONTHNAME(rental_date)
ORDER BY 2, 3 DESC;

+-------------+--------------+-------------+----------+
| customer_id | rental_month | num_rentals | rank_rnk |
+-------------+--------------+-------------+----------+
|         569 | August       |          18 |        1 |
|         119 | August       |          18 |        1 |
|         148 | August       |          18 |        1 |
|          15 | August       |          18 |        1 |
|         342 | August       |          17 |        5 |
...
|         351 | May          |           1 |      347 |
|          10 | May          |           1 |      347 |
|         136 | May          |           1 |      347 |
|          61 | May          |           1 |      347 |
+-------------+--------------+-------------+----------+
```
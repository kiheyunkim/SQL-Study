# 분석 함수

SQL에는 분석 처리에 유용한 함수 집합이 포함되어있음. 고객을 위한 재무 보고서를 생성하고, 3개월 연속 평균을 계산해야 할 경우, SQL이 기본 제공하는 내장 분석함수로 이러한 유형의 작업을 수행할 수 있음

## 분석 함수의 개념

데이터베이스 서버가 조인, 필터링, 그룹화 및 정렬을 포함하여 쿼리를 검증하는데 필요한 모든 단계를 끝내면 결과셋이 완성되어 호출자에게 반환될 준비가 됨. 이 시점에서 쿼리 실행을 일시 중지하고 메모리에 저장된
결과를 살펴볼 수 있다면. 결과셋에 판매 데이터가 포함되어 있다면 영업 사원 실적 순위 또는 지역에 대한 순위를 생성하거나, 특정 기간과 다른 기간 간의 백분율 차이를 계산할 수 있음. 분석함수를 사용하면 이러한
모든 작업을 수행할 수 있음.

### 데이터 윈도우

```sql
SELECT QUARTER(payment_date) quarter, MONTHNAME(payment_date) month_nm, SUM(amount) monthly_sales
FROM payment
WHERE YEAR (payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date);

+---------+----------+---------------+
| quarter | month_nm | monthly_sales |
+---------+----------+---------------+
|       2 | June     |       9631.88 |
|       2 | May      |       4824.43 |
|       3 | August   |      24072.13 |
|       3 | July     |      28373.89 |
+---------+----------+---------------+
4 rows in set (0.016 sec)
```

4개월 동안 7월간의 월간합계가 가장 높았고, 2분기에는 6월이 가장 높은 월간 합계를 보임. 프로그래밍 방식으로 가장 높은 값을 결정하려면 분기당 최대값 및 전체 기간에 대한 최댓값을 표시하는 열을 각 행에 추가해야함.
```sql
SELECT QUARTER(payment_date)                                      quarter,
	   MONTHNAME(payment_date)                                    month_nm,
	   SUM(amount)                                                monthly_sales,
	   MAX(SUM(amount)) OVER ()                                   max_overall_sales,
		MAX(SUM(amount)) OVER (PARTITION BY QUARTER(payment_date)) max_qrtr_sales

FROM payment
WHERE YEAR(payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date);

+---------+----------+---------------+-------------------+----------------+
| quarter | month_nm | monthly_sales | max_overall_sales | max_qrtr_sales |
+---------+----------+---------------+-------------------+----------------+
|       2 | June     |       9631.88 |          28373.89 |        9631.88 |
|       2 | May      |       4824.43 |          28373.89 |        9631.88 |
|       3 | August   |      24072.13 |          28373.89 |       28373.89 |
|       3 | July     |      28373.89 |          28373.89 |       28373.89 |
+---------+----------+---------------+-------------------+----------------+
4 rows in set (0.023 sec)
```

추가 열을 생성하는데 사용되는 분석 함수는 행을 두 개의 집합으로 그룹화 함. 하나는 모든 행을 포함, 다음하나는 모든 행을 포함함. 이러한 유형의 분석을 수용하기 위해 분석 함수에는 행을 윈도우로 그룹화하는 기능이
포함되어 있음. 이 기능은 전체 전체 결과셋을 변경하지 않으면서 분석 함수에서 사용할 데이터를 효과적으로 분할함.

윈도우는 선택적인 PARTITION BY 하위절과 결합된 OVER절을 사용하여 정의됨. 첫 번째 함수의 OVER절은 비어있으므로 윈도우 전체 결과셋에 포함되며, 두 번째 부석함수에는 같은 분기 내의 행에만 포함됨.
데이터 윈도우는 단일 행부터 결과셋에 전체 행에 이르는 모든 행을 포함할 수 있으며, 다양한 분석 함수로 각기 다른 데이터 윈도우를 정의할 수 있음.


## 로컬 정렬

분석 기능을 위해 결과셋을 데이터 윈도우로 분할하는 것과 함께 정렬 순서를 지정할 수도 있음.
```sql
# 판매량이 가장 높은 달에 값 1이 주어지는 각 월의 순위 번호를 정의하는 쿼리
SELECT QUARTER(payment_date)                   quarter,
	   MONTHNAME(payment_date)                 month_nm,
	   SUM(amount)                             monthly_sales,
	   RANK() OVER (ORDER BY SUM(amount) DESC) sales_rank

FROM payment

WHERE YEAR(payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date)
ORDER BY 1, MONTH(payment_date);

+---------+----------+---------------+------------+
| quarter | month_nm | monthly_sales | sales_rank |
+---------+----------+---------------+------------+
|       2 | May      |       4824.43 |          4 |
|       2 | June     |       9631.88 |          3 |
|       3 | July     |      28373.89 |          1 |
|       3 | August   |      24072.13 |          2 |
+---------+----------+---------------+------------+
4 rows in set (0.019 sec)
```

경우에 따라 동일한 분석 함수 호출에서 PARTITION BY 및 ORDER BY 하위절을 모두 사용하려 할 수 있음. 전체 결과셋에서 단일 순위 대신 분기별 순위를 제공하도록 이전 예제를 다음과 같이 수정할 수
있음.

```sql
SELECT QUARTER(payment_date)                                                      quarter,
       MONTHNAME(payment_date)                                                    month_nm,
       SUM(amount)                                                                montly_sales,
       RANK() OVER (PARTITION BY QUARTER(payment_date) ORDER BY SUM(amount) desc) qtr_sales_rank

FROM payment
WHERE YEAR(payment_date) = 2005
GROUP BY QUARTER(payment_date), MONTHNAME(payment_date), QUARTER(payment_date)
ORDER BY 1, MONTH(payment_date);

+---------+----------+--------------+----------------+
| quarter | month_nm | montly_sales | qtr_sales_rank |
+---------+----------+--------------+----------------+
|       2 | May      |      4824.43 |              2 |
|       2 | June     |      9631.88 |              1 |
|       3 | July     |     28373.89 |              1 |
|       3 | August   |     24072.13 |              2 |
+---------+----------+--------------+----------------+
4 rows in set (0.04 sec)
```

## 순위

### 순위 함수

SQL 표준에는 여러 순위 기능을 사용할 수 있으며, 각 순위 기능은 동점 처리 방식에 대해 서로 다른 접근 방식을 취함.
* row_number: 동점일 경우 순위가 임의로 지정된 각 행의 고유 번호를 반환함
* RANK: 동점일 경우 순위에 차이가 있는 동일한 순위를 반환함
* dense_rankL 동점일 경우 순위에 차이가 없는 동일한 순위를 반환함

상위 10명의 고객을 파악하여 무료 영화 대여 서비스를 제공하는 쿼리
```sql
# 각 고객의 영화 대여 수를 결정하고 결과를 내림차순으로 정렬
SELECT customer_id, COUNT(*) num_rentals
FROM rental
GROUP BY customer_id
ORDER BY 2 DESC;

+-------------+-------------+
| customer_id | num_rentals |
+-------------+-------------+
|         148 |          46 |
|         526 |          45 |
|         144 |          42 |
|         236 |          42 |
|          75 |          41 |
|         197 |          40 |
...
|         110 |          14 |
|         281 |          14 |
|         318 |          12 |
+-------------+-------------+
599 rows in set (0.01 sec)
```

세 번째와 네 번째 고객은 어떤 순서를 우선으로 잡아야할지 모름 동점을 처리하는 방식은 다음과 같음
```sql
SELECT customer_id,
       COUNT(*)                                   num_rentals,
       ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) row_number_rnk,
       RANK() OVER (ORDER BY COUNT(*) DESC)       rank_rnk,
       DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) dense_rank_rnk
FROM rental
GROUP BY customer_id
ORDER BY 2 DESC;


+-------------+-------------+----------------+----------+----------------+
| customer_id | num_rentals | row_number_rnk | rank_rnk | dense_rank_rnk |
+-------------+-------------+----------------+----------+----------------+
|         148 |          46 |              1 |        1 |              1 |
|         526 |          45 |              2 |        2 |              2 |
|         144 |          42 |              3 |        3 |              3 |
|         236 |          42 |              4 |        3 |              3 |
|          75 |          41 |              5 |        5 |              4 |
...
|         110 |          14 |            597 |      596 |             31 |
|         281 |          14 |            598 |      596 |             31 |
|         318 |          12 |            599 |      599 |             32 |
+-------------+-------------+----------------+----------+----------------+
599 rows in set (0.01 sec)
```
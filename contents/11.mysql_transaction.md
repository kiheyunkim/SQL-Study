# 트랜젝션

트랜젝션: 모든 SQL문이 성공하거나 성공하지 않도록 SQL 문 집합을 그룹화할 떄 사용하는 매커니즘

## 다중 사용자 데이터 베이스

이번 주의 영화 대여 내역을 요약한는 보고서를 생성한다고 가정하는 경우 다음과 같은 작업이 발생함
> * 고객이 영화를 대여함.
> * 고객이 반납일 이후 영화를 반납하고 연체료를 지불함
> * 5편의 새로운 영화가 재고에 추가됨.

위의 단계가 실행되는 동안에도 여러 사용자가 데이터를 수정할 수 있음.

보고서에는 어떤 숫자가 표시되어야할지는 **잠금 처리** 방법에 따라 달라짐.

### 잠금(locking)

잠금은 DB서버가 데이터 자원을 동시 사용을 제어하는 데 사용하는 메커니즘

DB의 일부가 잠기면 해당 데이터를 수정하거나 읽으려는 다른 사용자는 잠금이 해제될떄 까지 기다려야함. 대부분의 DB서버는 다음 2가지 잠금 방식중 하나를 사용

* 데이터베이스 write는 데이터를 수정하기 위해 쓰기 잠금을 서버에서 요청할때 수신해야 하며, 데이터베이스 reader는 데이터를 조회하기 위해 서버에 읽기 잠금(read lock)을 요청하고 수신해야함. 여러
  사용자가 동시에 데이터를 읽을 수 있지만 각 테이블(또는 그 일부)에 대해 한 번에 하나의 쓰기 잠금만 제공하고 쓰기 잠금이 해제될 때 까지는 읽기 요청이 차단됨
* 데이터베이스 writer는 데이터를 수정하기 위해 쓰기 잠금을 서버에 요청하고 수신해야하지만 reader가 데이터를 조회할 때는 어떠한 유형의 잠금도 필요하지 않음. 대신 서버는 쿼리가 시잘될 때부터 쿼리가
  완료될 때까지 reader에게 데이터에 대한 일관된 보기를 제공함(다른 사용자가 수정을 하더라도 데이터는 동일하게 보임). 이 접근방식을 버전관리(versioning)이라고 함

두 가지 접근방식은 모두 장단점이 있음.

* 첫 번째 방법은 동시 읽기와 쓰기 요청이 많으면 대기 시간이 길어질 수 있음. (SQL Server이 사용)
* 두 번째 방법은 데이터를 수정하는 동안 오래 실행되는 쿼리가 있으면 문제가될 수 있음.(Oracle이 사용)
* MySQL은 스토리지 엔진 선택에 따라 다름

### 잠금 단위

리소스를 잠글 때 사용할 수 있는 여러가지 방법이 있음. 서버는 세 가지 다른 수준 또는 단위 중 하나에서 잠금을 적용할 수 있음

* 테이블 잠금(table locks): 여러 사용자가 동일한 테이블의 데이터를 동시에 수정하지 못하도록 함
* 페이지 잠금(page locks): 여러 사용자가 테이블의 동일한 페이지(한 페이지는 보통 2KB에서 16KB 범위의 메모리 세그먼트)의 데이터를 동시에 수정하지 못하도록 함
* 행 잠금(row locks): 여러 사용자가 테이블에서 동일한 행을 동시에 수정하지 못하도록 함.

전체테이블을 잠그는 데는 부기가 거의 필요하지 않지만, 사용자 수가 증가함에 따라 대기 시간이 빠르게 증가함. 행잠금은 훨씬 많은 부기가 필요하지만 많은 사용자가 각자 다른 행에 대해 작업을 한다면 동일한 테이블을
수정할 수 있음.

* 데이터 베이스별 사용 잠금 단위
    * SQL서버: 페이지, 행, 테이블 잠금을 사용
        * 특정 상황에서 행에서 페이지로, 페이지에서 테이블로 잠금을 에스컬레이션(escalation)함
    * Oracle: 행 잠금만 사용
        * 에스컬레이션(escalation)을 하지 않음.
    * MySQL: 테이블, 페이지 또는 행 잠금을 사용

## 트랜젝션

여러 사용자가 동일한 데이터에 엑세스할 수 있도록 하는 요소 - 여러 SQL문을 함께 그룹화해서 모든 구문이 성공하거나 성공하지 않도록 하는 장치(**원자성**)

SQL문을 실행하며 모든 과정이 성공하며 COMMIT 명령어를 실행해서 거래를 종료하고 예상치 못한 일이 일어나면 프로그램은 ROLLBACK 명령어를 실행해서 트랜잭션이 시작된 이후의 모든 변경 사항을 취소함

```sql
# sudo code
START TRANSACTION;

# 첫번째 계좌에서 돈을 출금, 잔고가 충분한지 확인
UPDATE account
SET avail_balance = avail_balance - 500
WHERE account_id = 9988
  AND avail_balance > 500;

    IF <정확히 한 개의 행이 이전 구문에 의해서 업데이트 됨> THEN
        # 두번째 계좌로 입금
        UPDATE account
        SET avail_balance = avail_balance + 500
        WHERE account_id = 9989;

        IF <정확히 한 개의 행이 이전 구문에 의해서 업데이트 됨> THEN
        # 모두 처리되었다면 변경사항을 영구 적용
            COMMIT;
        ELSE
        # 문제가 발생하면 변경 사항 취소
            ROLLBACK;
        END IF;
    ELSE
    #자금 부족 또는 업데이트 중 오류 발생
    ROLLBACK;
END IF;
```

COMMIT이나 ROLLBACK이 실행되기 전에 서버가 종료되면 서버가 다시 온라인 상태가 될 때 트랜잭션이 롤백됨.(온라인 상태가 되기 전 데이터베이스 서버가 완료해야 하는 작업 중 하나가 서버가 종료될 때
진행중이던 불완전한 트랜잭션을 찾아서 롤백하는 것)

또 프로그램이 트랜잭션을 완료하고 COMMIT을 실행하였지만 변경 사항이 영구 스토리지에 적용되기 전에 서버가 종료되는 경우(수정된 데이터는 메모리에 있지만 디스크에 플러시되지는 않은 경우), 데이터베이스는 서버는
다시 시작될 때 트랜잭션의 변경 사항을 다시 적용함 이러한 속성을 **지속성(durability)** 이라고 함.

### 트랜젝션 시작
데이터베이스 서버는 다음 두 가지 방법 중 하나로 트랜잭션 생성을 처리함
* 활성 트랜잭션은 항상 데이터베이스 세션과 연결되어 있으므로 명시적으로 트랜잭션을 시작할 필요나 방법이 없음. 현재 트랜잭션이 종료되면 서버는 자동으로 세션에 대한 새 트랜잭션을 시작함
* 명시적으로 트랜잭션을 시작하지 않는 한 개별 SQL 문은 서로 독립적으로 자동 커밋됨. 트랜잭션을 시작하려면 먼저 시작 명령어를 실행해야 함.

Oracle은 첫 번째 접근 방식을 SQL 서버, MySQL은 두 번째 접근 방식을 사용함

오라클의 트랜잭션 접근 방식의 장점 중 하나는 단일 SQL 구문만 실행하더라도 롤백할 수 있다는 점. 그러나 MySQL이나 SQL 서버에서는 실행하면 영구 적용됨.

> SQL:2003 표준에는 명시적으로 트랜잭션을 시작하려고 할 때 사용할 start transaction 명령어가 포함되어 있음. MySQL은 표중을 따르지만 SQL 서버는 begin transaction 명령어를 대신 실행해야함.
> 
> 두 서버 모두 개별 세션에 대해 자동커밋 모드를 해제할 수 있음. 이 경우 서버는 트랜잭션에 관련하여 오라클 데이터베이스처럼 작동함.
> 
> ```sql
> # SQL 서버에서 자동커밋 모드를 비활성화
> SET IMPLICIT_TRANSACTIONS ON  
> ```
> ```sql
> # MySQL에서 자동커밋 모드 비활성화
> SET AUTOCOMMIT=0
> ```

자동커밋 모드를 비활성화하면 모든 SQL 구문이 트랜잭션 범위 내에서 실행되며 명시적으로 커밋되거나 롤백되어야함.
> 로그인할 때마다 자동커밋 모드를 종료하고 트랜잭션으로 모든 SQL문을 실행하는 습관을 들인다면, 실 수로 삭제한 데이터를 재구성하기 위해 DBA에게 요청해야 하는 상황을 피할 수 있음.

### 트랜젝션 종료

END TRANSACTION 명령어를 통해서 명시적으로, 또는 데이터베이스 서버에 의해 암시적으로 트랜잭션을 종료해야 변경사항이 영구 적용됨. COMMIT 명령어를 사용해서 서버가 변경 사항을 영구적으로 적용하고
트랜잭션 중에서 사용된 모든 리소스(페이지 또는 행 잠금 등)를 해제하도록 지시함.

트랜잭션 시작 이후의 모든 변경 사항을 실행 취소하려면 ROLLBACK 명령어를 실행해서 트랜잭션 전 상태로 되돌리도록 서버에 지시해야함. 롤백이 완료되면 세션에서 사용된 모든 리소스가 해제됨.

* COMMIT 또는 ROLLBACK 명령어를 실행했을 떄 이외의 다른 작업의 간접 결과로 또는 제어할 수 없는 어떤 이유로 트랜잭션이 종료될 수 있는 몇 가진 시나리오가 있음.
  * 서버가 종료되고 서버가 재시작되면서 트랜잭션이 자동으로 롤백됨
  * ALTER TABLE같은 SQL 스키마 문을 실행하면 현재 트랜잭션이 커밋되고 새로운 트랜잭션이 시작됨.
  * 다른 START TRANSACTION 명령어를 실행하면 이전 트랜잭션이 커밋됨
  * 서버가 교착 상태(DEAK LOCK)을 감지했을 때 해당 트랜잭션이 원인이라고 판단되면 서버는 트랜잭션을 조기 종료함. 이경우에는 트랜잭션이 롤백되고 오류 메세지가 표시됨.

> 2번째의 케이스: 새 테이블이나 인덱스 추가 또는 테이블에서 열 삭제와 같은 데이터베이스 변경은 롤백할 수 없으므로, 스키마를 변경하는 명령어는 트랜잭션 외부에서 수행해야 함.
> 
> 4번째 케이스: 서로 다른 두 개의 트랜잭션이 다른 트랜잭션이 현재 보유하고 있는 리소스를 대기할 때 발생함.
 
 
### 트랜잭션 세이브 포인트
경우에 따라 트랜잭션 내에서 문제가 발생하여 전체를 롤백할 수도 있지만 실행한 모든 작업을 취소하지 않을 수도 있음. 이런 상황에서는 트랜잭션 내에 하나 이상의 세이브 포인트를 설정하고 이를 이용해서 완전히 롤백하는 대신 트랜잭션 내의 특정 위치로 롤백할 수 있음.

```sql
# 세이브 포인트 설정
SAVEPOINT my_savepoint;

# 특정 세이브 포인트로 롤백
ROLLBACK TO SAVEPOINT my_savepoint;
```

```sql
#사용 예시
START TRANSACTION;

UPDATE product SET date_retired = CURRENT_TIMESTAMP() WHERE product_cd = 'XYZ';

SAVEPOINT before_close_accounts;

UPDATE account SET status = 'CLOSED', close_date = CURRENT_TIMESTAMP, last_activity_date = CURRENT_TIMESTAMP() WHERE product_cd = 'XYZ';

ROLLBACK TO SAVEPOINT before_close_accounts;
COMMIT;
```

* 세이브 포인트 사용시 주의 사항
  * 이름을 지정했음에도 세이브포인트를 생성하면 아무 것도 저장되지 않음. 트랜잭션을 영구화하려면 commit을 실행해야 함.
  * 세이브포인트의 이름을 지정하지 않고 ROLLBACK을 실행하면 트랜잭션 내의 몯느 세이브포인트가 무시되고 전체 트랜잭션이 실행 취소됨.


> 스토리지 엔진 선택
> 
> 오라클 데이터 베이스 또는 마이크로소프트 SQL서버를 사용할 때, 단일 코드 집합은 기본 키 값을 기반으로 테이블에서 특정 행을 조회하는 등 낮은 수준
> 의 데이터베이스 작업을 담당함. 그러나 MySQL은 서버는 리소스 잠금과 트랜잭션 관리를 포함한 낮은 수준의 데이터베이스 기능을 제공하기 위해 여러가지 스토리지 엔진을 활용할 수 있또록 설계되어있음.
> 
> * MySQL 8.0 버전에 포함된 스토리지 엔진
>   * MyISAM: 테이블 잠금을 사용하는 nontransaction 엔진 
>   * MEMORY: 인메모리 테이블에 사용되는 nontransaction 엔진
>   * CSV: 데이터를 쉼표로 구분해서 파일에 저장하는 트랜잭션 엔진
>   * InnoDB: 행 수준 잠금을 사용하는 트랜잭션 엔진
>   * Merge: 여러 개의 MyISAM 테이블을 단일 테이블로 표시하는 특수 엔진(테이블 분할)
>   * Archive: 주로 보관 목적으로 대량의 인덱싱되지 않은 데이터를 저장하는 특수 엔진
> 
> MySQL은 테이블 별로 스토리지 엔진을 선택할 수 있을 만큼 유연함. 트랜잭션을 사용해야 하는 테이블의 경우 행 수준 잠금과 버젼 관리를 제공하며 여러 스토리지 엔진 중에서도 최고 수준의 동시성을 제공하는 InnoDB엔진을 선택해야함
> ```sql
> show table status like 'customer';
> 
> *************************** 1. row ***************************
>           Name: customer
>         Engine: InnoDB
>        Version: 10
>     Row_format: Dynamic
>           Rows: 599
> Avg_row_length: 136
>    Data_length: 81920
>Max_data_length: 0
>   Index_length: 49152
>      Data_free: 0
> Auto_increment: 600
>    Create_time: 2021-11-17 00:41:53
>    Update_time: NULL
>     Check_time: NULL
>      Collation: utf8mb4_0900_ai_ci
>       Checksum: NULL
> Create_options:
>        Comment:
>1 row in set (0.00 sec)
> ```
> 
> ```sql
> # 테이블이 사용하고 있는 엔진을 INNODB로 교체하는 방법
> ALTER TABLE customer ENGINE = INNODB;
> ```